local ffi = require("ffi")
local bit = require("bit")
local ig = require("scripts.cimgui")
local nfd = require("scripts.nfdex")
local json = require("scripts.luaLibs.dkjson")
local csv = require("scripts.luaLibs.csv")
local helpers = require("scripts.helpers")
local sdl = require("scripts.SDL3")

-- =========================================================
-- 1. UTILITIES
-- =========================================================

local debug = ""

local function ImVec2(x, y)
  return ffi.new("ImVec2", x, y)
end

local function ImVec4(x, y, z, w)
  return ffi.new("ImVec4", x, y, z, w)
end

-- Robust Base Path Helper
-- Returns the directory where the executable is located
local function get_base_path()
  local path_ptr = sdl.SDL_GetBasePath()
  if path_ptr ~= nil then
    local path = ffi.string(path_ptr)
    if ffi.os == "OSX" then
      local app_idx = path:find("/[%a%s%d]+%.app/Contents/Resources/$")
      if app_idx then
        path = path:sub(1, app_idx - 1) .. "/"
      end

      app_idx = path:find("/SerieMiniGUI/LuaJIT/$")
      if app_idx then
        path = path:sub(1, app_idx - 1) .. "/"
      end
    end
    sdl.SDL_free(ffi.cast("void*", path_ptr))
    return path
  end
  return "./" -- Fallback for non-bundle runs
end

-- Store base path once at startup
local BASE_PATH = get_base_path()
--debug = BASE_PATH

-- Helper to read file content (Bundle-Aware + Fallback)
local function read_file(path)
  -- 1. Try via SDL Base Path (Standard for App Bundles -> Resources/)
  local abs_path = path:gsub("^%./", BASE_PATH) -- concat filename to base_path
  local f, err = io.open(abs_path, "r")

  debug = tostring(err)
  
  -- 2. Fallback: Try direct relative path (Development/Console mode)
  if not f then
      f = io.open(path, "r")
  end

  -- Return nil and the path we tried if both failed
  if not f then return nil, abs_path end
  
  local content = f:read("*a")
  f:close()
  return content
end

-- Helper to write file content (Bundle-Aware)
local function write_file(path, content)
    -- Try writing to Base Path first
    local abs_path = path:gsub("^%./", BASE_PATH)
    local f = io.open(abs_path, "w")
    
    -- Fallback to relative
    if not f then
        f = io.open(path, "w")
    end
    
    if f then
        f:write(content)
        f:close()
        return true
    end
    return false
end

-- Helper to uppercase first letter (for labels)
local function first_upper(str)
  return (str:gsub("^%l", string.upper))
end

function contains(list, value)
  for _, v in ipairs(list) do 
    if v == value then return true end
  end
  return false
end

-- Helper to extract JSON from the JS config file
local function parse_js_config(content)
  -- We extract the JSON object between "{" and "};"
  local json_start = content:find("{")
  local json_end = content:find("};") 
  
  if json_start and json_end then
    local json_str = content:sub(json_start, json_end)
    -- decode using dkjson
    local obj, pos, err = json.decode(json_str)
    return obj
  end
  return nil
end

-- Function to copy string to char array safely
local function set_char_buffer(buffer, text, size)
  if not text then return end
  ffi.fill(buffer, size) -- Clear buffer
  ffi.copy(buffer, text)
end

-- =========================================================
-- THEME SETUP 
-- =========================================================

local style_init = false
local function setup_theme()
    local style = ig.GetStyle()
    
    -- Modern Rounding
    style.WindowRounding = 8.0
    style.FrameRounding = 6.0
    style.PopupRounding = 6.0
    style.ScrollbarRounding = 12.0
    style.GrabRounding = 6.0
    style.TabRounding = 6.0
    

    local colors = style.Colors
    
    -- --- Backgrounds ---
    colors[ig.ImGuiCol_WindowBg]         = ImVec4(0.08, 0.08, 0.11, 1.00)      -- Deep Navy/Slate (Main Background)
    colors[ig.ImGuiCol_PopupBg]          = ImVec4(0.12, 0.12, 0.16, 0.98)      -- Slightly Lighter for Popups
    colors[ig.ImGuiCol_FrameBg]          = ImVec4(0.30, 0.30, 0.33, 1.00)      -- Dark Gray-Blue (Input/Frame Background)

    -- --- Text and Checkmark ---
    colors[ig.ImGuiCol_Text]             = ImVec4(0.90, 0.92, 0.95, 1.00)      -- Off-White/Light Gray
    colors[ig.ImGuiCol_CheckMark]        = ImVec4(0.25, 0.65, 0.95, 1.00)      -- Bright Accent Blue
    header_color                         = ImVec4(0.30, 0.60, 0.90, 1.00)

    -- --- Frame/Input States ---
    colors[ig.ImGuiCol_FrameBgHovered]   = ImVec4(0.20, 0.20, 0.28, 1.00)      -- Darker Hover
    colors[ig.ImGuiCol_FrameBgActive]    = ImVec4(0.25, 0.25, 0.35, 1.00)      -- Dark Blue Active

    -- --- Title Bar ---
    colors[ig.ImGuiCol_TitleBg]          = ImVec4(0.09, 0.09, 0.13, 1.00)      -- Slightly Darker than WindowBg
    colors[ig.ImGuiCol_TitleBgActive]    = ImVec4(0.15, 0.15, 0.22, 1.00)      -- Dark Slate Blue

    -- --- Tabs ---
    colors[ig.ImGuiCol_Tab]              = ImVec4(0.10, 0.10, 0.14, 1.00)      -- Background Tab
    colors[ig.ImGuiCol_TabHovered]       = ImVec4(0.30, 0.55, 0.85, 1.00)      -- Brighter Blue Hover
    colors[ig.ImGuiCol_TabSelected]      = ImVec4(0.25, 0.50, 0.80, 1.00)      -- Accent Blue Selected

    -- --- Buttons ---
    colors[ig.ImGuiCol_Button]           = ImVec4(0.18, 0.45, 0.70, 1.00)      -- Primary Medium Blue
    colors[ig.ImGuiCol_ButtonHovered]    = ImVec4(0.30, 0.60, 0.90, 1.00)      -- Lighter Blue Hover
    colors[ig.ImGuiCol_ButtonActive]     = ImVec4(0.15, 0.40, 0.65, 1.00)      -- Darker Blue Active

    -- --- Headers/Selectables ---
    colors[ig.ImGuiCol_Header]           = ImVec4(0.18, 0.45, 0.70, 0.50)      -- Primary Blue (50% Opacity)
    colors[ig.ImGuiCol_HeaderHovered]    = ImVec4(0.30, 0.60, 0.90, 0.80)      -- Lighter Blue Hover (80% Opacity)
    colors[ig.ImGuiCol_HeaderActive]     = ImVec4(0.25, 0.55, 0.85, 1.00)      -- Medium Blue Active
end

-- =========================================================
-- 2. LOCALIZATION
-- =========================================================

local lang = "es" -- Default language

local texts = {
  es = {
    tab_config = "Configuración",
    tab_tasks = "Tareas (NPM)",
    header_basic = "Información Básica",
    header_meta = "Metadatos",
    lbl_username = "Usuario GitHub",
    lbl_repo = "Repositorio",
    lbl_title = "Título Colección",
    lbl_subtitle = "Subtítulo",
    lbl_credits = "Créditos",
    lbl_copyright = "Copyright",
    lbl_show = "Metadatos a Mostrar (Página del Ítem)",
    lbl_index = "Metadatos a Indexar (Buscador)",
    btn_save = "GUARDAR CONFIGURACIÓN",
    msg_saved = "¡Configuración guardada en data/serie.config.js!",
    msg_loaded = "Configuración existente cargada.",
    err_csv = "Error: No se encontró",
    err_pid = "Error: La tabla de metadatos no tiene la columna pid (exactamente, sin mayúsculas ni espacios)",
    err_label = "Error: La tabla de metadatos no tiene la columna label (exactamente, sin mayúsculas ni espacios)",
    desc_tasks = "Ejecutar comandos de Node.js. La salida se mostrará abajo.",
    btn_install = "Instalar Dependencias (npm install)",
    btn_tasks = "Estructurar Colección (npm run tasks)",
    btn_update = "Actualizar Colección (npm run update)",
    btn_preview = "Iniciar Servidor de Previsualización (npm run preview)",
    btn_stop = "Detener Servidor",
    btn_build = "Construir Sitio de Producción (npm run build)",
    console_title = "Consola de Salida",
    console_waiting = "Esperando comandos...",
    console_running = "> Ejecutando ",
    console_start_server = "> Iniciando servidor de desarrollo...",
    console_stopping = "> Intentando detener servidor...",
    console_stopped = "> Servidor detenido.",
    console_stop_fail = "> No se pudo detener (o no estaba corriendo)."
  },
  en = {
    tab_config = "Configuration",
    tab_tasks = "Tasks (NPM)",
    header_basic = "Basic Information",
    header_meta = "Metadata",
    lbl_username = "GitHub Username",
    lbl_repo = "Repository Name",
    lbl_title = "Collection Title",
    lbl_subtitle = "Subtitle",
    lbl_credits = "Credits Text",
    lbl_copyright = "Copyright Text",
    lbl_show = "Metadata to Show (Item Page)",
    lbl_index = "Metadata to Index (Search Bar)",
    btn_save = "SAVE CONFIGURATION",
    msg_saved = "Configuration saved to data/serie.config.js!",
    msg_loaded = "Existing configuration loaded.",
    err_csv = "Error: Not found",
    err_pid = "Error: metadata table does not contain the pid column",
    err_label = "Error: metadata table does not contain the label column",
    desc_tasks = "Run Node.js commands. Output will be shown below.",
    btn_install = "Install Dependencies (npm install)",
    btn_tasks = "Structure Collection (npm run tasks)",
    btn_update = "Update Collection (npm run update)",
    btn_preview = "Start Preview Server (npm run preview)",
    btn_stop = "Stop Server",
    btn_build = "Build Site (npm run build)",
    console_title = "Output Console",
    console_waiting = "Waiting for commands...",
    console_running = "> Running ",
    console_start_server = "> Starting dev server...",
    console_stopping = "> Stopping server...",
    console_stopped = "> Server stopped.",
    console_stop_fail = "> Could not stop (or not running)."
  }
}

-- =========================================================
-- 3. APP STATE
-- =========================================================

local app = {}
local buf_size = 256

-- Form State
local state = {
  username = ffi.new("char[?]", buf_size, ""),
  repo = ffi.new("char[?]", buf_size, "serie-mini"),
  title = ffi.new("char[?]", buf_size, "Serie Mini"),
  subtitle = ffi.new("char[?]", buf_size, "Un sistema para mini colecciones digitales"),
  credits = ffi.new("char[?]", buf_size, "Por ..."),
  copyright = ffi.new("char[?]", buf_size, "Todos los derechos reservados, " .. os.date("%Y")),
}

-- Item types
local item_types = {"text", "link", "ref", "video", "audio", "youtube"}

-- Metadata State
local available_keys = {}
local checked_show = {}  
local type_show = {}
local checked_index = {} 

-- UI State
local status_msg = ""
local status_color = { 0, 1, 0, 1 }
local csv_loaded = false

-- Console State
local log_filename = "npm_log.txt"
local log_lines = {}
local log_timer = 0
local log_file_pos = 0
local auto_scroll = false

-- =========================================================
-- 4. LOGIC
-- =========================================================

-- Helper to run commands asynchronously by piping to file
local function run_async_task(cmd_str)
  -- Reset console
  log_lines = {texts[lang].console_running .. cmd_str}
  log_file_pos = 0
  
  -- Create/Clear the log file using bundle-aware path
  if not write_file(log_filename, "...\n") then
      table.insert(log_lines, "> Error: Cannot write log file.")
      return
  end
  
  -- Resolve absolute path for the log file for the shell command
  local abs_log_path = BASE_PATH .. log_filename
  
  -- Fix path for 'npm' on Mac/Linux GUI apps
  -- GUI apps don't inherit $PATH, so we must explicitly add common bin locations
  local path_fix = ""
  if ffi.os ~= "Windows" then
      path_fix = "export PATH=$PATH:/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin && "
  end
  
  -- Construct command based on OS
  local full_cmd = ""
  
  if ffi.os == "Windows" then
    -- 'start /min' runs cmd in a minimized window
    full_cmd = 'start /min cmd /c "' .. cmd_str .. ' > "' .. abs_log_path .. '" 2>&1"'
  else
    -- Mac/Linux: 'cd' to BASE_PATH to ensure we are in project root
    -- then run command with fixed PATH and redirect output
    full_cmd = 'cd "' .. BASE_PATH .. '" && ' .. path_fix .. cmd_str .. ' > "' .. abs_log_path .. '" 2>&1 &'
  end
  
  os.execute(full_cmd)
end

-- Helper to kill node processes
local function stop_server_task()
  local kill_cmd = ""
  if ffi.os == "Windows" then
    kill_cmd = "taskkill /IM node.exe /F"
  else
    kill_cmd = "pkill node"
  end
  
  table.insert(log_lines, texts[lang].console_stopping)
  auto_scroll = true
  
  local result = os.execute(kill_cmd)
  
  if result then
     table.insert(log_lines, texts[lang].console_stopped)
  else
     table.insert(log_lines, texts[lang].console_stop_fail)
  end
end

function app.Load()

  -- 1. Load CSV (Metadata structure)
  -- Updated to capture error path for debugging
  local content, err_path = read_file("./data/metadata.csv")

  if content then
    local parsed = csv.openstring(content)
    local iter = parsed:lines()
    local headers = iter() -- Get first row

    local has_pid = contains(headers, "pid");
    local has_label = contains(headers, "label");

    if not has_pid then
      status_msg = texts[lang].err_pid
      status_color = { 1, 0, 0, 1 }
      csv_loaded = false
      return
    elseif not has_label then
      status_msg = texts[lang].err_label
      status_color = { 1, 0, 0, 1 }
      csv_loaded = false
      return
    end
  
    if headers then
      available_keys = {}
      for _, h in ipairs(headers) do
        local key = h:gsub("^%s*(.-)%s*$", "%1")
        table.insert(available_keys, key)
        -- Set defaults
        checked_show[key] = false
        type_show[key] = "text"
        checked_index[key] = false
      end
      csv_loaded = true
    end
  else
    -- Display detailed error path
    status_msg = texts[lang].err_csv .. "\n(" .. (err_path or "?") .. ")"
    status_color = { 1, 0, 0, 1 }
    return
  end

  -- 2. Try to load existing configuration
  local existing_config_str = read_file("./data/serie.config.js")
  if existing_config_str then
    local loaded_config = parse_js_config(existing_config_str)
    
    if loaded_config then
      -- Set Language
      if loaded_config.lang == "en" then lang = "en" else lang = "es" end
      
      -- Helper to extract username from base URL
      local base = loaded_config.base or ""
      local uname = base:match("https://(.-)%.github%.io")
      
      -- Helper to extract repo from baseurl
      local baseurl = loaded_config.baseurl or ""
      local repo_name = baseurl:match("^/(.+)")
      
      -- Populate Form State
      set_char_buffer(state.username, uname or "", buf_size)
      set_char_buffer(state.repo, repo_name or "serie-mini", buf_size)
      set_char_buffer(state.title, loaded_config.title, buf_size)
      set_char_buffer(state.subtitle, loaded_config.subtitle, buf_size)
      set_char_buffer(state.credits, loaded_config.credits, buf_size)
      set_char_buffer(state.copyright, loaded_config.copyright, buf_size)
      
      -- Populate Metadata Settings
      if loaded_config.pages then
        -- Restore "Show" settings
        if loaded_config.pages.metadataToShow then
          for _, meta in ipairs(loaded_config.pages.metadataToShow) do
            if meta.key then
              checked_show[meta.key] = true
              type_show[meta.key] = meta.type or "text"
            end
          end
        end
        
        -- Restore "Index" settings
        if loaded_config.pages.metadataToIndex then
          for _, key in ipairs(loaded_config.pages.metadataToIndex) do
            checked_index[key] = true
          end
        end
      end
      
      status_msg = texts[lang].msg_loaded
      status_color = { 0, 1, 0, 1 }
    end
  end
end

function app.Update(dt)
  -- Poll the log file every 0.1 seconds
  log_timer = log_timer + dt
  if log_timer > 0.1 then
    log_timer = 0
    
    -- Use Bundle-Aware read for the log
    local f = io.open(BASE_PATH .. log_filename, "r")
    
    -- Fallback read if base path fails
    if not f then f = io.open(log_filename, "r") end

    if f then
      f:seek("set", log_file_pos)
      local new_content = f:read("*a")
      
      if new_content and #new_content > 0 then
        log_file_pos = f:seek()
        for line in new_content:gmatch("[^\r\n]+") do
          table.insert(log_lines, line)
          if #log_lines > 1000 then table.remove(log_lines, 1) end
          auto_scroll = true
        end
      end
      f:close()
    end
  end
end

function app.Draw()
  if not style_init then
      setup_theme()
      style_init = true
  end

  local t = texts[lang]
  local io_gui = ig.GetIO()

  ig.SetNextWindowPos(ImVec2(0, 0))
  ig.SetNextWindowSize(io_gui.DisplaySize)
  ig.Begin("Serie Mini Setup", nil, bit.bor(ig.ImGuiWindowFlags_NoDecoration, ig.ImGuiWindowFlags_NoMove))

  ig.Text(debug)

  ig.Text("Serie Mini")
  ig.SameLine()

  local avail_w = ig.GetContentRegionAvail().x
  ig.SetCursorPosX(avail_w - 150)
  if ig.Button(lang == "es" and "Idioma: Español" or "Language: English") then
    lang = (lang == "es") and "en" or "es"
  end
  ig.Separator()

  if status_msg ~= "" then
    ig.TextColored(ImVec4(unpack(status_color)), status_msg)
  end

  if ig.BeginTabBar("MainTabs") then

    -- TAB 1: CONFIGURATION
    if ig.BeginTabItem(t.tab_config) then
      if csv_loaded then
        ig.Spacing()
        ig.TextColored(header_color, t.header_basic)

        ig.InputText(t.lbl_username, state.username, buf_size)
        ig.InputText(t.lbl_repo, state.repo, buf_size)
        ig.InputText(t.lbl_title, state.title, buf_size)
        ig.InputText(t.lbl_subtitle, state.subtitle, buf_size)
        ig.InputText(t.lbl_credits, state.credits, buf_size)
        ig.InputText(t.lbl_copyright, state.copyright, buf_size)

        ig.Spacing()
        ig.Separator()
        ig.Spacing()

        ig.TextColored(header_color, t.header_meta)

        ig.Columns(2, "metacolumns", true)

        -- Col 1
        ig.Text(t.lbl_show)
        ig.Spacing()
        for _, key in ipairs(available_keys) do
          local b = ffi.new("bool[1]", checked_show[key])
          if ig.Checkbox(key .. "##show", b) then
            checked_show[key] = b[0]
          end
          
          if b[0] then
            ig.SameLine()
            ig.PushItemWidth(100)
            if ig.BeginCombo("##type" .. key, type_show[key], 0) then
              for _, type_opt in ipairs(item_types) do
                local is_selected = (type_show[key] == type_opt)
                if ig.Selectable_Bool(type_opt, is_selected, 0, ImVec2(0,0)) then
                  type_show[key] = type_opt
                end
                if is_selected then ig.SetItemDefaultFocus() end
              end
              ig.EndCombo()
            end
            ig.PopItemWidth()
          end
        end

        ig.NextColumn()

        -- Col 2
        ig.Text(t.lbl_index)
        ig.Spacing()
        for _, key in ipairs(available_keys) do
          local b = ffi.new("bool[1]", checked_index[key])
          if ig.Checkbox(key .. "##index", b) then
            checked_index[key] = b[0]
          end
        end
        ig.Columns(1)

        ig.Spacing()
        ig.Separator()
        ig.Spacing()

        if ig.Button(t.btn_save, ImVec2(avail_w, 40)) then
          local config_data = {
            lang = lang,
            localPort = "5173",
            base = "https://" .. ffi.string(state.username) .. ".github.io",
            baseurl = "/" .. ffi.string(state.repo),
            title = ffi.string(state.title),
            subtitle = ffi.string(state.subtitle),
            credits = ffi.string(state.credits),
            copyright = ffi.string(state.copyright),
            pages = {
              iiifViewer = true,
              metadataToShow = {},
              metadataToIndex = {}
            }
          }

          for _, k in ipairs(available_keys) do
            if checked_show[k] then
              table.insert(config_data.pages.metadataToShow, {
                key = k,
                label = first_upper(k),
                type = type_show[k] or "text"
              })
            end
            if checked_index[k] then
              table.insert(config_data.pages.metadataToIndex, k)
            end
          end

          -- Indent string "  " for dkjson
          local json_output = json.encode(config_data, { indent = "  " })
          local file_content = "const config = " .. json_output .. ";\n\nexport default config;"

          -- Use Bundle-Aware write
          if write_file("./data/serie.config.js", file_content) then
            status_msg = t.msg_saved
            status_color = { 0, 1, 0, 1 }
          else
            status_msg = "Error: Permission denied writing file."
            status_color = { 1, 0, 0, 1 }
          end
        end
      end
      ig.EndTabItem()
    end

    -- TAB 2: TASKS
    if ig.BeginTabItem(t.tab_tasks) then
      ig.Spacing()
      ig.TextWrapped(t.desc_tasks)
      ig.Spacing()

      -- Buttons Block
      if ig.Button(t.btn_install, ImVec2(-1, 0)) then
        run_async_task("npm install")
      end

      ig.Spacing()

      if ig.Button(t.btn_tasks, ImVec2(-1, 0)) then
        run_async_task("npm run tasks")
      end

      ig.Spacing()

      if ig.Button(t.btn_update, ImVec2(-1, 0)) then
        run_async_task("npm run update")
      end

      ig.Spacing()
      
      local inner_w = ig.GetContentRegionAvail().x
      local half_w = inner_w * 0.5 - 5

      -- Dev Server Controls (Start and Stop)
      ig.PushStyleColor_Vec4(ig.ImGuiCol_Button, ImVec4(0.2, 0.6, 0.2, 1)) -- Green for Start
      if ig.Button(t.btn_preview, ImVec2(half_w, 0)) then
        table.insert(log_lines, texts[lang].console_start_server)
        auto_scroll = true
        
        if ffi.os == "Windows" then
           os.execute("start /min npm run preview")
        else
           -- Use async task so environment variables are set correctly
           run_async_task("npm run preview") 
        end
      end
      ig.PopStyleColor()
      
      ig.SameLine()
      
      ig.PushStyleColor_Vec4(ig.ImGuiCol_Button, ImVec4(0.8, 0.2, 0.2, 1)) -- Red for Stop
      if ig.Button(t.btn_stop, ImVec2(half_w, 0)) then
        stop_server_task()
      end
      ig.PopStyleColor()

      ig.Spacing()

      if ig.Button(t.btn_build, ImVec2(-1, 0)) then
        run_async_task("npm run build")
      end
      
      ig.Spacing()
      ig.Separator()
      ig.Spacing()

      -- CONSOLE WINDOW
      ig.Text(t.console_title)
      
      ig.PushStyleColor_Vec4(ig.ImGuiCol_ChildBg, ImVec4(0.1, 0.1, 0.1, 1))
      -- Use user's specific binding: BeginChild_Str
      if ig.BeginChild_Str("Console", ImVec2(0, -1), true, 0) then
          
          if #log_lines == 0 then
              ig.TextDisabled(t.console_waiting)
          else
              for i, line in ipairs(log_lines) do
                  ig.TextUnformatted(line)
              end
              
              if auto_scroll then
                  ig.SetScrollHereY(1.0)
                  auto_scroll = false
              end
          end
          
      end
      ig.EndChild()
      ig.PopStyleColor()

      ig.EndTabItem()
    end

    ig.EndTabBar()
  end

  ig.Text("v1.0.0 - Sergio R. G. - 2025")
  ig.End()
end

app.Load()
return app

-- if ig.Button(t.btn_locate, ImVec2(avail_w, 50)) then
--   -- Open Native Folder Picker
--   local result, path = nfd.pickFolder(BASE_PATH)
--   if result then
--     if path:sub(-1) ~= "/" and path:sub(-1) ~= "\\" then
--         path = path .. "/"
--     end
--     -- UPDATE GLOBAL BASE PATH FOR EVERYTHING (including NPM)
--     BASE_PATH = path
    
--     -- Reset error flag and try to reload
--     permission_error = false
--     app.Load()
--   end
-- end